import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit';
import {RootState, AppThunk} from '../../Store';
import {getMoviesFromApi} from './MovieAPI';
import {RootObject} from './Model';

export enum FetchMovieAction {
  fetch,
  fetchMore,
  refresh,
}

export interface MovieState {
  data?: RootObject | undefined;
  status:
    | 'idle'
    | 'loading'
    | 'loadingMore'
    | 'refreshing'
    | 'failed'
    | 'success';

  error: any;
}

const initialState: MovieState = {
  status: 'idle',
  error: null,
};

export const fetchMovieAsync = createAsyncThunk(
  'movie/fetchMovie',
  async (page: number) => {
    const response = await getMoviesFromApi(page);
    // The value we return becomes the `fulfilled` action payload
    return response?.data;
  },
);

export const fetchMovie =
  (action: FetchMovieAction): AppThunk =>
  async (dispatch, getState) => {
    const state = getState().movie;
    const currentPage = state.data?.page ?? 1;
    const page =
      action === FetchMovieAction.refresh
        ? 1
        : action === FetchMovieAction.fetchMore
        ? currentPage + 1
        : currentPage;
    try {
      if (action === FetchMovieAction.refresh) {
        dispatch(refresh());
      } else if (action === FetchMovieAction.fetchMore) {
        dispatch(loadMore());
      } else {
        dispatch(loading());
      }
      const response = await getMoviesFromApi(page);
      if (action === FetchMovieAction.fetchMore) {
        const data = state.data;
        const oldDataResults = data?.results ?? [];
        const newDataResults = response?.data?.results ?? [];
        const finalDataResults = [...oldDataResults, ...newDataResults];
        const result = {
          ...response?.data,
          results: finalDataResults,
        } as RootObject;
        dispatch(success(result));
      } else {
        dispatch(success(response?.data));
      }
    } catch (error) {
      dispatch(failure(error));
    }
  };

export const movieSlice = createSlice({
  name: 'movie',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    loading: state => {
      state.status = 'loading';
    },
    success: (state, action: PayloadAction<RootObject | undefined>) => {
      state.status = 'success';
      state.data = action.payload;
    },
    failure: (state, action: PayloadAction<any>) => {
      state.status = 'failed';
      state.error = action.payload;
    },
    loadMore: state => {
      state.status = 'loadingMore';
    },
    refresh: state => {
      state.status = 'refreshing';
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      .addCase(fetchMovieAsync.pending, state => {
        state.status = 'loading'; // TODO
      })
      .addCase(fetchMovieAsync.fulfilled, (state, action) => {
        state.status = 'success';
        state.data = action.payload;
      })
      .addCase(fetchMovieAsync.rejected, state => {
        state.status = 'failed';
      });
  },
});

export const {loading, success, loadMore, refresh, failure} =
  movieSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectMovie = (state: RootState) => state.movie.data;

export default movieSlice.reducer;
